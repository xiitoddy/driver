what's up guys welcome to my new cheat series that kernel drivers going to be reading and writing memory and the user mode clients gonna be doing most of the calculations and I'll probably add an overlay as well so it'll wind our wall hacks and stuff like that basically we're gonna hook a random function here the one I'm using this video is called query composition surface statistics okay big word so what we're gonna do is I'm gonna show you guys in my virtual machine here after I explain this how to refine this reverse this and we're gonna look at the assembly and stuff like that and we're gonna make our shell code and basically what it's gonna do is it's gonna say move our hook address which is going to be the address of our function in our driver or however you load your driver is going to be wherever it is in two racks which is a register and then we're gonna jump to racks which is it's gonna jump to our function and execute our function and then our function is basically gonna have access to the parameters of this function here and what's the parameter gonna be it's gonna be instructions for our driver and we're gonna say let's say this is completely example let's say there's a boolean read and we say is read true yes it's true let's read process memory okay otherwise if write is true we're gonna write price this memory and then after all that we're gonna return status success which means it's basically just not going to run the rest of this function here so essentially what's gonna happen is every time we call this function here or every time this function gets caught it's gonna call that hook and then it's just gonna return so okay we've got our kernel hook in place now how do we actually call this function from user mode from our client right well what we're gonna do is we're gonna load a library and we're gonna export the function and then we're gonna make our end little struct here copy memory whatever and we got this little bull read/write and we make a pointer we're going to set where the instructions we want they're going to be much more variables because we're gonna need a buff address the extra address we want to read the value to write etc then we call the function from user mode which calls the function in kernel write so we call that with the parameters that we want it calls the kernel version kernel function runs what does it do runs out hook goes over to our driver runs our hook function and we get access the parameters and it's our struct so we say you know is read true whatever like I explained before once we do all the instructions we return okay simple as that so the user mode calls the kernel function where our hook is in kernel mode our hook runs we check the instructions the parameters whatever maybe we didn't even call it so if none of these are true whatever it's still returns okay and that's pretty much it so we get to communicate without driver and run this function with instructions whenever we want oh hey guys how's it going so we're gonna disassemble the function here I'm gonna use a win dbg so I'm in the debug program yeah I'm gonna click kernel debug since I'm in a VM here I'm just gonna do a local debugging alright so once you've got the command line open gonna have to do a few commands yeah so we're gonna have to attach to a session space process and she can do that with the Explorer tada you see like that oh no like that this is how we get the code and then go to the dot process slash P and then put the code yeah and there we go so now we need to reload the driver we want to disassemble which in our case is DHG kernel Dutchess I forgot that you oughta put slash ahead before the name and then that's it so we can go into a disassembly view and just type in the function name up Yong will see the function so the name of the one we're doing is an T query actually first I'll show you guys how you can find the functions so hopefully let me restore the page yeah here we go so I'll leave a link to this down below this is just that from Firefox it's a table pretty much of a bunch of functions some of these aren't gonna work but most of the composition ones do in my experience I just look through them these lines won't work I'm pretty sure with NTD composition I'm pretty sure that they won't work better if you go down lower these ones usually work so handle info I think this one is fine so here's our function here query surface statistics so you can just copy that chuck it into the windbg up here paste it and it will show you the function straightaway now sure you guys had to find like another function if you guys want to make your own hook let's say you guys choose this one handle info or something how this one looks pretty good actually so I'll try to find one that is like a bad one probably this one just so you guys know from my experience at least alright this one looks good as well okay yikes what the very way okay this one surely unbind surface very high here we go so functions like this where they have this security cookie instruction yeah yeah you don't want to hook down one okay in my experience it just blue screens you no matter what you do so I'm pretty sure it's like some sort of security check obviously so if it's got this security cookie thing don't hook that function look for ones that don't have this yeah this security cookie thing so make sure your function doesn't have that and you should be good I just went through like two or three just now in a row and none of them had that so you should be fine but just so you know I try not to hook functions with that if it's got this critical region thing that's fine you can hook those bad other security cookie ones are you know a bit of a Ikes so I'm gonna go on the one that I'm using for the example doesn't really matter at the end of the day you can use the same shell code for like most of these functions what we want to do is we want to do a move and a jump now the move racks is going to be two bytes so let's move racks and then it's going to be another eight bytes for our function address right so that's ten bytes in total for the first address alphabet basically for the first instruction we're going to need ten bytes then for the jump rax we're going to need another two bytes so we only need 12 12 bytes for this hook okay you just so you guys can kind of get a wrap your head around it a little better I've got a the driver here that I'm going to code in this video I've got already compiled obviously I'm gonna run it yeah this is just Kady mapper you guys I'm sure you can get Kady map it yourself so I'm gonna load this driver and I'm gonna show you how it changes the function here so you guys can see what we're doing exactly now I'm just going to run it there we go and I'm gonna reload the function basically so I'm just going to delete the s but the s back there we go it's refreshed you can see how it looks in place so what do I mean by that well you can see his first address has a lot of bytes so if you can see the first address here move racks and then it's got our function address so this is the address of the hook function right now and then after that it's just jump racks so we're putting our function address into rax and then we're jumping there okay simple as that and then the five seven to end into push hard I interesting yes that's pretty much it every time this function gets cold it's gonna run this line puts our function address into rax and then it jumps there that's it executes our function so I think this is our function here the hook function and basically all I have it to do right now is just return and yeah you can see you're right here I just wrote it so yeah that's basically the hook that's how you find a function how you disassemble it you know look at the bytes whatever now I'm going to show you how to actually code the driver so let's start coding this driver it is not going to be a USB driver so you want to do an empty KMD F Drive apparently I'm just going to call it this one first thing I'm going to do is some of the settings the project settings to help you guys get a successful build so very cool so you want it to be x64 release of course whatever you want to make sure character set is not set what else info to cat you don't want that to run driver signing you want that off okay and what else link oh yeah you want to make sure drive entries actually drive the entry and there's one more thing I forgot about it I think that's it well if we run into a problem I'll show you guys how to fix it so first thing I'm gonna add here is a bunch of the definitions for like the undocumented functions and stuff that we're going to use yeah so the way you can find this kind of stuff is you can just go and react OS and there you go you see like the function definition they see the arguments what it returns stuff like that so react device is really good for finding these kind of undocumented structures or functions so you can try and implement them into your Windows stuff yeah so if you guys want to just copy it out from the video here it is it's not too much I'll just scroll through it's got a couple includes here and then it's got these structures here and it you know and then couple function definitions which we're gonna need so you guys can pause the video whatever shameless plug there's a link down below to my patreon might be top comment or in the description and on my patreon five bucks a month you can get access to all my source code from every single one of my videos so try that it's basically a one-time payment because I only upload like once a month see ya man just five bucks you can get access to all this source code you even get a supporter all in my discord you get access to locked channels in my discord where I actually read them and reply of course if you're asking dumb questions simple questions that can be answered by Google I'm not gonna entertain them I'm probably gonna troll you or someone else who's gonna troll you speaking of discord there's gonna be a link down below either pin comment or description or you can join my discord we got a bunch of people there so we've got the definitions here next thing is we're gonna do so next thing is going to be a memory header I'm just going to define some functions so we want to include definitions and then define some function so first time we're going to need is getting module base and that's going to take a parameter of what module we want next is gonna be get it module export and then we're gonna need two more functions yeah we're gonna need a little write memory function it's going to need the address buffer and the size and then we're going to need you to write it to read any memory cool so include memory all right so we're gonna coat the functions now gonna have to include that header file there first function hopefully zoom did enough for you guys I'll do a little bit more because I know some you guys like to code while watching the video and so having Adam didn't helps a lot so we want to query the module information here so we're going to pass it a little ennum value that and then no and then we're gonna pause the bites you and then pause that queue if not so if the bite is invalid we want to return nothing and then otherwise keep going okay so when you're making a pool here and you make a tag basically pass this hexadecimal value which is converted from text so that's gonna be the name of your tag the one time I'm just gonna make one right now show you guys how you can make it so like text to hex go yeah put in whatever text you want I'm just going to do now and there you go that's the hex you want to put in for the tag which isn't coming of a scene so hey you gonna do 0x get rid of the gaps okay there you go and that's it I can only be four letters I'm pretty sure all right so that's our tag there and it says no you know because that's I'm gonna say if NT status whoops success and then we pass status return now qo Leos - I'm talking guys I woke up like half an hour ago and I'm just I'm drinking coffee and trying to focus and I'm just I really do be vibey you know I really do be buddy we've already done a string comparison oh my god so I'm gonna just explain some of these code because I like literally disconnected IRL so getting a list of the modules okay and then we're looping through the modules this is equivalent if you're doing like a user mode external this is pretty much the equivalent of taking a snapshot of the process list or whatever or [ __ ] what is that the module list or some [ __ ] so we're living through these modules here we're comparing the name of the so we're comparing the path name of V so we're comparing the name of the module that we're looping through to the one we pass in the argument and we're seeing if it returns zero it means it matches so if it matches then we found our module so we want to save some of the information from that module demo so we obviously want the module base right because that's why use for the address calculations I'm sure you guys already know this I mean if you're doing kernel kernel reversing in kernel programming I mean I'm sure you know all this but I don't know I just don't know what else to talk about when I'm coding so ichael so save the module base and the module size and then we can break after that clean up y'all so if modules we want to free that that I had a tag modules I mean you can pass the null for that doesn't matter I like to use null instead of zero because my name uh null cool and if you look at what null means guess what it means it literally means zero so so after all that we want to return obviously what we got which is module bar say alrighty now that was probably the biggest function in this like entire [ __ ] program so that's why I I went into Super Saiyan cool these other functions are pretty simple so next is gonna be get module export a I believe that's what we called it yet you know and that's got a shop owner cure yes all right so we're gonna need module pointer and that's gonna be returned from this bad boy we can pass module I think I'm going right now where I'm going yeah yeah so got a waypoint on the module and then basically we just say is that valid if it's not year 18 home what we do return null don't all right so otherwise it works and then we just return RTL find exported routine by name and the routine name which is going to be the function name essentially which we want to hook kyoool so that's that function then we're gonna need the right memory functions so I'm gonna make a nice small ride memory a little kind of like a wrapper here it's gonna need to address buffer and the size and all it's going to do is just use this definition here RTL copying memory and basically all that does is it calls mem copy okay so you can use mem copy all that interchangeably that I believe they're big English but I believe the but I believe the parameters are a little different not to shoulder so basically if that failed to be returning false otherwise we want to return true because I worked so there you go if you look at this definition is just mem copy so you can put mem copy there's only manner anyway now we're doing a cool so this is what we're gonna use to write to read only memories crazy right like the function name describes what it does it's crazy so so I misspelled the function name there obviously IRL biquette MDL very cool return false cool and that's why they are queuing it to read Ryan nice see ya what we're doing here is we're basically just a mapping memory and we're giving it the readwrite access I think I spelled this wrong meant to be cached cool that looks good yeah cool so once we've done that we can write the memory so we just got a write memory wherever mapped and then the buffer size cool and then we're gonna need to clean up everything so gonna need to unwrap the locked pages and then unlock them I had freed the memory descriptor cool and then we going to entry because I wait he's not cool so that's all the memory functions I think we're gonna need so i actually forgot a line in the memory file here i forgot to add another query here so we need to do z w query system information again am i passing the same flag yo at this time we're gonna use the modules variable and I completely miss spelt it there you go so that's the line I forgot I add that line and then should work that's pretty much like the bulk of the coding now we can move on to like the hook which is the fun pot so I'm gonna do a new header file here hook da fiel so for some reason I made a namespace here so I'm just gonna do this same thing again I guess null hook doesn't that sound cool I'm gonna make this whole kernel function what's this gonna do it's kind of cool the kernel function so nt status look handle and this is pretty much gonna be a hook right and then this is the parameters that were given to the function Coolio is now we can card these out so we're gonna do the basically we're gonna set up the function that makes the hook or sets the hook basically so that's gonna be cool kernel function and it takes you in whatever thing we want to hook so this is gonna be the address of that hook function so we want to make sure that address is correct or at least it's valid because what's the point of trying to hook something if the hook isn't real um function address so we're gonna return false if that's not valid so we need to get the address of the function we want to hook it's also called I'm just going to call it function and we're gonna need to do a cost here so reinterpret costs to avoid point on oh well P void point oh and we got to use that little function here which is gonna be they get the exponent so we need to pass the directory to the driver which is in system root system 32 and then drivers and then the name which is DHT kernel dot sis I think that's right let me system area system 32 yeah cool and then the name of the routine that you would hook so our one was query composition surfer statistics we want to make sure that's valid as well so if not function it's gonna be a byte array and I'm just gonna make this I'm gonna say oreag basically you just want to be 12 bytes long doesn't really matter what this is so basically what you can do here is you can put the original instructions from the function so when you disassembled it you could see the original instructions then you could copy paste the bytes into here basically what that would mean is when you do the whole credit is leftover bytes in this array it'll put the right bytes in if that makes sense but basically the way I do it is there's not gonna be any leftover bytes because I only need 12 for the hook and I'm gonna put 12 in this array so it just doesn't really matter I'm just as long as this is 12 bytes long which I don't know what I'm up to him up to one two three four five six seven eight I think at 12 you can just hover over here and you can see the size of the array so it's 12 cool that's 12 bytes which is how long a hook is gonna be now if it was like a detour hook where it where it runs the hook and then it goes back to the original function that's when it would matter to put the actual original bytes in here because you don't want to crash basically you want to have the right instructions that are meant to be executed but since we're not returning to the original function it's just running our hook it doesn't really matter as long as there's enough space for our hook that's all we care about so we got our shellcode yeah and that's gonna be high 0 x4 8 0 XB 8 and what that translates to is this is jump and this is rax so it's going to be jump right oh sorry move rax no jump rax that's the next one so this is gonna be move rax and then afterwards would be our function address so it would be something like you saw the original I did show you guys the actual instructions I did show you guys the actual eye assembly in the windbg if you remember that but I'll just kind of type it out here so it would be move rax if you remember and then it was like ffffff whatever how address was right so that's what this line is doing and then the next one's going to be the end all right so this is jump rack so it's jump rack school yeah so this is jump racks yeah so it's very simple it's just jump racks and what's in racks now function address so it's gonna jump to our function hook function now we've got that shellcode set up we're gonna do the actual writing of memory yeah now I just want to say this right here is what's detected by bad align easy antichain okay they cig scan for this they sick scan for a move racks and a jump racks okay so if you change the signature of this shellcode right here it's going to be undetected by be e and e AC that's all I'm gonna say okay this is the method I use for my personal hack and it's been undetected for like a month okay I use different shellcode obviously I'm not gonna show you the shellcode but I just want you guys to know you can't actually make this undetected very easily okay I'm gonna say that it's very easy so hopefully that inspires you guys to mess around with this and change the shellcode it'll be undetected but if you want to just use the shellcode here it'll still work but it it will only be undetected by back okay you'll get banned in Baddeley and stuff like that so let me get to so we're going to do the actual hook yeah and we're going to put our egg and the size of the original bytes Brittney's mem copy how what type of cost to a white point iron then ilan point I want to put a rig and then the shell code starts okay I'm gonna get the hook address yeah it's gonna be another reinterpret cost Q this is saying bad why huh LM L so you want to put another bracket after this thing here I forgot about that anyway we got the hook address now we're gonna do another mem copy yeah P void it's gonna be sighs a void pointer because it's just a pointer to a function address and then we're doing another mem copy when I'm just gonna copy paste this by now honestly like this gonna be our egg plus size of the shellcode and we also want to do the size of the function address which is Waypoint and then we want to put the end finally and that's gonna be the size of whatever that is there we go all right so now we're gonna actually write the shell code to the function so this is where we're riding the hook so this is the function address and then we want to do shell code there's gonna be size of the show code so basically what we're doing here is we're getting the instructions ready to be ridden so the first thing we're doing is we're copying the move racks into here and then after the move racks we put the hook address right which is this yeah copy the book address into that and then lastly we're copying the jump racks at the end which would be the last two bytes into there that's pretty much the hook right there okay okay so after that we want to return true because it actually hooked and now every time that function runs its gonna run out so now we want to actually write the whole function right we want to write the function that runs and that's going to be kodou book Handler and we want access to the parameters Young so eventually this parameter is gonna be our some sort of structs we're gonna make and that's gonna stall the instructions on what we want to do but for now just to cut this video short honestly it's going for way too long already we're just going to make a return success to see if the hook works and see for blue screens or not so I'm gonna compile this see if I get any errors hopefully not actually I have an even ton I haven't even made the main alrighty so it's time to do the main function and this is gonna be easy we just wanted to extern see empty status drive entry or whatever you made it in the linker settings if you followed what I did at the start it would be drive entry and I'm spelling this completely wrong drive on object so since I'm using Katy mapper I can't actually use the driver object or the registry path so I'm gonna do an reference parameter for both of them and then I'm uh then we just need to call the hook pass the address all right so after that we just need to call the hook oh well set the hook and then pass our book function just a hook hand alone and that should be it then we can return success um cool so let's see I do have some areas down here so I'm going to see what they are so it it just means this is the last sitting I forgot to do it's treating warnings as errors so I think that's in in C++ yep here we go three warnings as areas you want that as no and then it should let you compile awesome so I'm gonna help you my VM and try load it and see what happens alrighty so I'm in my VM now I've compiled e driver and I've disassembled the function here so let's see if it works I'm gonna load it with KD mapa there we go the hook works so we've got the move racks and then the address of the hook function and then we jump racks simple as that I'm gonna go to the hook address here and you can see like before it's just returning yeah so that's basically it the next part to this is going to be adding the user mode client and communicating with the driver and adding that memory struct to make the driver read and write and do what we want

second part in the kernel we're going to be doing the user mode client in this one now in part one we did the hook which was in dxg kernel.cis we hooked whatever function we looked and then we did a basic move racks jump racks and that's what's gonna call our hook function here and basically we're gonna use that in this video we're gonna make a little client here uh what does that mean it's just gonna be an exe right and uh we're gonna make a structure here for like our instructions and then we're gonna call the hook function with the instructions okay that's very basic but that's basically what we're doing so part one was pretty advanced that's why it was such a long video and i feel like it was kind of fast-paced but in comparison this video is going to be much simpler uh there's no disassembling we're just going to be coding this one um all i'm doing is i'm just going to make a structure and then i'm going to make a little hook function uh oh i'm going to make a function to call the hook function and that's pretty much it um we're going to be able to read write get a process base whatever so by the end of this um you'll be able to use the driver and you know you could hack cs go or whatever by the end of this video if you wanted to so um yeah let's get into it all right so we're going to be adding a new project okay so we're going to add a new project here and this is going to be our user mode component so i'm just going to call it kernel cheat um alrighty um all right cool so we've got our user mode thing here gonna make the main cool all right so let's start coding it we're going to do the includes as usual cool so that's what we're going to need i'm going to show you guys the shot that we're going to be using to communicate so it's gonna be a type def cool and we're gonna need quite a few things in here so first thing i'm going to need is a buff address then i'm going to need the actual address we want to work on and the size uh process id and then whether or not we want to read and write what else whether we want to request the base address of the outputs and then the module name for if we want to get the base address so that's it and then i'm going to make cool um so that's our structure there you're going to want to copy this into the kernel thing because you're going to need in the kernel uh probably put it in here right or maybe it should be fine cool all right so you want to make sure you put in your kernel driver i just put it in the memory file all right so because i can't be [ __ ] i'm going to make global variables which is usually bad but i don't really care um study cool yes i don't know why that's static that doesn't need to be static so we've got our structure global variables now we're going to do the hook function and this is going to be pretty epic so i'm going to use a template type name cool all right so we got a template going it's going to return you in 64. holy [ __ ] yeah cool so using type name for the arguments so we can work on like whatever you want there's jackets on my chest so i'm gonna cool all right so this is where we're going to call the actual kernel hook so we need to export the function so the function that we hooked is in win32.dll and if you used a different function it'll still be in here so basically any function that was in dxg kernel uh that we could have hooked right there that i showed you in that uh page or whatever it's going to be in this dll so you guys can if you even if you hooked a different function you can use the same dll here and in this parameter you just want to put the function name that you hooked so we did uh query composition surface statistics but you guys can put whatever you did um but if you guys had a different function you just put the function name in here and it'll still work fine so so this is where we're exporting the function so we're getting the address of the function and then we're basically doing a static cast making a standard call and then setting up our arguments here for the call and then this is where we call the function with the arguments and now we need the function to get a process id and i'm just going to use this function i'm pretty sure it's from like unknown cheats yeah i did not make this but it works you know so cool alrighty so i'm getting this string view error pretty sure it's because my settings are on so yeah so you're laying which standard you want it to be i think 17 or the one above yeah there you go cool now this is the actual function where we get the process id so this is just uh for when we loop through the handles we have a little like function here that's about wrong as well so we got this operator function here and basically it's going to help us cycle through the handles so if it's not null and if it's not in vandal and if it's not invalid then we close the handle yeah cool so this is where we're taking a snapshot of all the processes apparently okay i'm gonna say if okay so if it's an invalid handle obviously we don't want that so we return now and then we need to set the size of this cool and this is where we're going to loop now so we say process 32 next a while post is 32 next uh with the snapshot handle why isn't it coming up cool there we go cool so just copy the settings that i just did there and it should fix all the errors um and then i think that's it for this function we just need to do a little thing here return null if that failed so this is just like any other like process id function or handle function it just takes a snapshot loops through it and then compares this this the one that we want and then returns our process id okay um i just like it because it uses this handle disposer thing which is kind of cool but um yeah i didn't make that i copied it off unknown sheets or something i don't know where i got it from so the next thing is cool all right so from so now we can start doing the um like instruction functions pretty much so okay so this one's going to be for getting the module base address and first thing we're going to need to create a struct of null memory and i'm going to call it instructions i guess so this is like going to be instructions for our driver kind of um and now we can set the variables so if we want to get the module base address we're going to need to set the process id which hopefully we're going to set with the global variable and then we want to say request base is true because that's what we want and then everything else is going to be false pretty much so read false and right should be false cool now we set the module name that we want so that's going to be the parameter um and that's it we can call the hook and pass instructions so that's going to pass by reference call name why is it called why did i do that all right so we're doing the ampersand here to pass the actual address of instructions which is going to be a pointer to instruction hands um cool wait what oh hello we're going to ulong64 and i'm going to call a base address and that's going to store the base address of the function classic all right cool so that's the base address thing you can use this for any module so let's say csgo you want to do client.dll you just pass client.dll it'll get you the base address of that or if you pass csgo.exe it'll get the base address of the process right so that's what's awesome about so that's what's awesome about this function next we're going to do the reading and writing which is exciting so we're going to use a template for the reading of course because you guys are going to be using it for a bunch of different data types so it's easier when you use a template because it'll work for like whatever data type you want and i like to use snake case actually oh no cool so we're gonna make a response variable here all right so we're going to need the response and of course the instructions that's going to be the process id so it's going to be size of whatever data type you've passed here um and then we're going to need to set a lot of variables here so the address is going to be whatever address you want to read and then we're going to set the booleans so read is true the other one's going to be false i might just copy this and paste it every time uh right is gonna be false and what's the other one request base that's gonna be false two and then the outputs can be uh the address of response and then we can call the hook pass our instructions cool and then return response which is whatever we uh read so that's the read function so we're gonna do the right function now so we're going to need the address we want to write to uh the source address and cool now this needs to be not like that cool so we're going to need um instructions as usual and then yeah i've still got it pasted cool so address is going to be the right address so right is going to be true because we want to write everything else is going to be false we're going to need a buff address i'm going to type cost yeah that's going to be right size cool and then we can call the hook with the instructions and we can return true because it worked i guess cool all right so we've got that i'm going to make a little wrapper for this function that's going to use template and this one's only going to need like two parameters compared to three and we can just return this function here with these parameters so that's going to be that we're going to typecast this i'm gonna say value right and then uh it's gonna be size of whatever that is cool all right so now we have to code the actual uh hook in the kernel driver to read the instructions and it should be pretty um simple shouldn't be too long so first thing we're going to do here is we're going to typecast the parameter as our structure and i don't think it's defined here because i put in cpp not the h there we go so now we have a pointer to our instructions we can check what we need to do so first i'm going to check if it's to request a module base so if that's not false which means you know if it's true then we're gonna get a model base so here we're just converting it the model name where is this function defined all right so these are the functions we're gonna need we're gonna need three more functions here one to get the base one to read one to right so the first thing we're going to do is the get module based on and this is for x64 so we want to get the peb of the process and if that's invalid we're going to return so what we're doing here is we're basically attaching to the process um so i guess i don't have this defined we're gonna need a lot more definitions here i just pasted these you can just search these on like react os and then copy and paste them so we need underscore peb rtl user process parameters uh the data table entries and even the peb loader datas so yeah search these up paste them or you can copy it from the video all right so we want to make sure that's valid if it's not we need to uh detach since we attached already now we can loop all right cool so we're looping through the linked list here so so now we're comparing the names if we got the right one now we can unstack and on we can detach and then we return the base address of the module and then after all that still fails then we need to detach and return cool so that's for the module base next we need uh to do the read and write functions gonna need prices id so we want to validate the arguments first before we do anything just to make sure the driver went blue screen and whatnot cool so that's where it's actually reading the memory yes copying the virtual memory and we want to check what status is if it worked or not cool so that's for the read and then we need to do the so now we need to do write process memory we're going to do the same checks is up here cool i'm just going to copy that all right then we attach and we're gonna get some info here okay so if the query failed we detach and return uh nothing should be false even it's gonna be the same thing really but um so it's pretty obvious what we're doing here just making sure the arguments are right and now we can actually write to the memory so we want to make sure that so we want to do a lot of checks on the memory to make sure that we can actually write it and that it's valid and whatnot because it's very easy to cause like a blue screen otherwise hello okay so basically checking all the flags here that would let us right to the memory and basically um if it's any one of these then we can write to it so we're going to do rtl copy memory and then we can return truth into uh let us copy all right so that's all the functions now we can go back to the hook and use these cool cool so that's to get the base and then next will be if we want to write so i'm gonna do a quick check here to make sure the address is in a valid memory range okay just in case in your user mode client you don't do proper checks and then you do pass the address as 0 or something this will make sure it uh when blue screen cool now we can use our function here cool so that's for the writing memory next is reading memory and that should be the last one so i'm going to do the same check here and this is going to be very short here i've already done the check all right so this should be just the one line right here because we've already done the function so cool then we can return success awesome so that's our new hook function we check if we want to request the base if we want to write and if we want to read that's all the functions that we need so i'm going to make a little main function and test it out i guess for this series i'm going to be using rainbow six siege for an example just because it's a lot easier to hack ugh classic [ __ ] four minutes okay should be fine um so i was going to test this out on um rainbow six yeah but um rainbow six is updating so whatever let's see if this takes five minutes to code so i'll just do a little stuff here otherwise if the base address is correct i'm just going to say yes oh cool god [ __ ] [ __ ] so we're going to be using now get module based address

thank you guys so much for 10 000 subscribers i genuinely didn't even think i would actually hit that number when i was around seven to eight thousand on discord i made my name next video at 10k because i thought i'm never gonna hit that so i'm just gonna like quit youtube and that's it here we are you guys actually kept subscribing even though i haven't uploaded a proper video for like almost a year we still hit 10 000 subscribers and thank you so much um it really means a lot it shows me that you guys actually enjoy my videos if you have any video ideas leave a comment down below once again thank you so much for 10 000 subscribers i'm really grateful for it it means a lot enjoy this video what's going on guys this is going to be the last episode of the kernel series we're basically just going to draw esp from our kernel driver we're just going to implement uh the win gdi functions in our driver so basically a quick rundown on wingdi it stands for windows graphics driver interface so it's just a programming interface core operating system component and it lets you just output to your screen so what can we use that for we can draw lines curves boxes and text in this video we're focusing on the boxes but you can follow the same steps in this video to implement draw text or lines or whatever you want drawing a box so in user mode you can just use the function frame rec and that's going to basically just draw a box on your screen now we can't exactly call this function from our kernel driver so how we're going to do it well we're going to look at what this function actually does and this is from react os and as you can see all this function does is it selects the brush that you want to use to draw and then it calls this function pad blt to draw the rectangle the first thing it does is it saves the current brush before drawing and then once it's done drawing with the brush you want it sets it back to the old brush so next thing we need to do is just look at these functions here select object and pad blt and see if we can call them from the kernel a way we can do this is shout out to this guy no idea how to say his name but i'm just going to say guru we're going to look at the windows syscalls now i usually use his website but it's down at the moment so i'm going to use this github now this might look a little familiar we did use this in part one when we were looking for a function to hook but now we're just looking at functions to export and call so what this is is it's just a bunch of syscalls from the win32k driver and the reason we're interested in this one is because it stores a bunch of the graphics cisco's for the gdi so what we can do is we can just control f and look for the functions that we're interested in i was looking at get dc before don't worry about that before we get into this i just want to say head over to my patreon it'll be linked below patreon.com null terminator five dollars a month you get access to the source code from this video and all the other videos on my channel and recently i've been uploading the compiled files as well so for the kernel cheat tutorial for part one and two you can just have access to the files straight away you can check out the code as well you'll have all the source code so this is all you've got to do just search the function you want to look at and then just react os and it'll pop up here so here's the code for frame rack the first function i want to look at is select object now i don't really care about this line because i'm just going to delete this line but we do need this one because we need to set it to the brush that we want so it takes in the hdc which is a handle to the device context and it takes in the object that you want to select okay now what this function does is it just has a switch case and it just looks for which type of object you're trying to select but in this case since we're just implementing frame rates we're trying to select a brush so let's see what would happen so it does checks what handle type it is it's not a region type not a bitmap it's a brush type and of course this function select brush so let's just do this function so this one is a bit more specific nice takes in htc and a brush which is exactly what we want so we'd probably just want to call this function anyway but let's look at the syscalls and check if select object is in there and uh it's not in here so let's look at select brush okay so select brush is in here so that means we can export it and call it from our kernel driver next function we're going to need is this thing pat blt so same as select object we're just going to check if it's in here and if it is then we can just call it directly otherwise oh it isn't here so we can export um select not select object we can export select brush and replace select object with select brush because it's doing the same thing and then we can just export pat blt as well to do this part so let's um implement this in the code i'm using the same project from part one and two i just downloaded this from my patreon because i'm pretty sure i've lost the original project but anyway i'm just having a quick look through here and there's a couple things i want to change um i don't know why i did this not equal default it should be something like this i'm not even doing else ifs i'm just doing if statements it could do three operations in one call which is not how it's designed it's meant to be one operation per call so i'm just going to add the else fcr to make it safer because you don't really want to just request the base but then it ends up writing some random bit of memory or whatnot anyway all right great so how do we actually implement this into our code and export these functions so all you want to do is let's start with select brush so you just copy this part here paste it into the code and you want to just add a bit so you want to say type def i don't think that matters do this this and then you want to add a semicolon right there man and that's it so now we have a typedef for the function we had another function pad blt so copy this i'm pretty sure this is x y width high yeah so i'm pretty sure that's right and then the last one the word cool no okay so we're just going to do the same thing type dev and get rid of this okay great so we need to export another function to actually get the device context and the way you do it in user mode is with get dc so first thing we want to check is if there's just a kernel function we can export that does it for us but if there isn't then that's when you want to go in react os look at the user mode function and see what kernel functions it calls and you're going to have to basically just replicate the user mode function in kernel right and call the functions it's calling by exporting those specific functions luckily there's a syscall that we can just export and call so it's going to be enter user get dc so this is it in react os i clicked on it just to get this side here that we can just copy and paste and we're just gonna have to do this type def thing again just like that so we have select brush uh pad blt and get dc let's see if we need any more okay yeah so we're going to need to create the brush as well which doesn't show up here but it requires a brush as a parameter so the way you do it in windy eyes you just create brush so i'm just going to search create first i'm going to search brush so i don't know what it's called exactly so i'm just going to go through all of these and there we go so we see create solid brush which is just the kernel uh syscall that we can export so since we can export it i'm going to search it in react os um this one and then we just copy this i'm sorry if this is a little all over the place i usually have like a second monitor to keep me on track with like notes and stuff i don't have that anymore and i'm kind of just doing this on the fly so we got select brush pad blt get dc create brush let's just triple check make sure we're not missing any other function so we can get the dc the rectangle is just uh we create our own rectangle we can create the brush we can select the brush and we can draw the actual rectangle okay i think that's it so it returns an int and it takes this so i'm just honestly just gonna oh my god now i'm just gonna add the function in this namespace here so i'm gonna copy that uh do the um get rid of this there you go dude copy that again go down here paste it add this all right cool now we can just paste this code into here we're going to add our own parameter here for the thickness delete this line replace select object with select brush replace pad blt with nt pad blt and lastly replace the one with the thickness parameter and there we go our own frame wrecked function the video you just been watching was recorded a week ago after that point i kind of ran into some problems when i was trying to get this to work but i've solved those issues it's a week later and i'm going to finish off the video the functional hooking for some reason when you hook that function and then you open like google chrome it blue screens your computer but the way i fix it is just by hooking a different function everything else is the same you just change the function name here you can copy the one i'm using here it'll work perfectly fine it also comes up in the syscall table that we've been using here i'm pretty sure these other functions around it will work as well they're very similar so that fixes the blue screen next problem for some reason win32k doesn't come up in this module list so we're gonna have to make another module export function that can actually find the base address of the win32k modules so we need to make a function that's going to get a routine address and it takes in the routine name that's going to be a really short function we need a unicode string and we're basically just going to convert the parameter into a unicode string and we're converting it to a unicode so that we can pass that into this function here and that'll work so that's the function there next we're going to pretty much make a new version of this function here so i'm going to copy this paste it and this needs to be a wsdr again well we can delete all this if you want more information on what i'm about to do here you can check out this grade right up here there's two different write-ups this first one has a bunch of information on a lot of windows internals and other things like that i'll link it in the description we're looking at how to get kernel module addresses so the method we've been using is similar to this method that he puts here the query system information method but this wasn't working for me because win32k wasn't coming up for me it says i it works for him but it wasn't working i just switched over to another method down here which is the ps loaded modulus method uh we're going to be doing it a similar way to this but i just wanted to give credit to this guy because this is where i learned about this this second write up here goes into a lot more detail if you really want to understand what's happening so this gives a nice visualization of the module list and it also goes into depth with the kernel debugging okay great so let's start putting it into code first thing we're going to need is module list and we're going to get it using a little function that we coded up here and we want to say es loaded module list awesome so that's how you get the module list i'm going to quickly check if that pointer is valid now that we have the list how do we actually traverse it so basically the way we're going to loop this is going to look a little different if you haven't worked with doubly linked lists before we're basically just going to say while we're not at the end of the list just go to the next link in the list so we're going to create a new variable here it's going to be a place entry and that's going to be the link and we're going to start at the top of the list and we want to say while it's not the bottom of the list it's going to be b link equal the next element in the list right but while we're not at the bottom keep going through the list so now that we're in the list okay that's going to be the entry and we want to use containing record at link it's going to be a data table entry and we want to do the first field so this one right here just like that now that we have the entry we can check if it's the right module we're going to need another unicode string here and it's going to be the module name and we're going to be comparing the entry based dll name so that's going to be the module name right with the one we're looking for and we want it to be case sensitive so if they match we're returning the base address oh so if the base is valid we're going to export the routine pass the base and then the routine name we're looking for otherwise if the dll base is null now that we have these export functions that we can use head over to our hook.cpt i've already got the just recorded this by the way my computer crashed and i lost the recording so i'm doing it again so some of the code is still here but we're going to have to create the function variables right using the type defs that we created earlier and you just want to set it to null initially here i guess just pause the video and copy this out but what we're going to do is we're going to actually use the export functions in our call kernel function here so this is where we set the hook and because this only runs one gonna put this code in here as well because we only want it to run one so we can set our function addresses now the way we're going to do this is by setting the function address we want to type cast the return of our function that we just created so it gets the module export and you want to make sure you're passing a wstr so it uses the right function because if you don't use this l here it's going to go to the other version here so you see we have two versions with the same name so make sure that's a wstr or select brush it's in win32k full if you want to know which module it's in you can just use winddbg you can load win32k full and win 32k base and then search for whatever function you're looking for so if you're looking for select brush you just search select brush in win dbg and it'll tell you which module it's in it'll be something like this formation mark and then like select brush or whatever the function name is that's going to be the module editing and then we want to put the routine name which is going to be like this with nt at the start i think so now we need to do this exact same thing with all the other functions i'm just going to edit that for you this is create solid brush at blt get dc release dc and delete object app so i just realized i i've added these two functions here um when i was fixing the code so i think you guys wouldn't won't have these type devs here so i'll show you guys the type devs you can go on react os search these functions here if you want to get the function definitions like that or just pause the video and copy these two type devs here these are the type def for the two function so we're gonna need these two functions um to release the hdc our device context handle and this is going to be to delete the handle to the brush that we create now we can use them in our hook we just scroll down here and we're going to add another if statement and we're going to say if we want to draw a box we're going to use these functions here so we're going to need a new boolean and some ins in our struct here so you want to add a boolean raw box and you want to add rgb x y width height and thickness as in and we're going to need these to draw the actual box the first thing we're going to have to do is get the htc using our exported function and we pass null in there so that we get the device context for the whole screen the entire monitor so we can draw anywhere we want i'm going to quickly check if this handle is valid and if it's not and unsuccessful next we need uh the brush we're going to use create solid brush you want to pass rgb which is a macro this is defined in wingdi.h so make sure you include that it's got r g b and it's from zero to two five okay so we wanna pass our instructions for r g and b and then you wanna pass knob once again i'm going to check if the brush is a valid handle just like that now we can actually draw the rectangle oh well we actually need to create the rectangle first and that's going to be the x y the x plus the width and then it's the y plus the height now we can call frame rect as hdc plus the rectangle the brush and the thickness but now we've drawn the rectangle just need to release the hdc and the brush and we do this using the new exports that we've added and you want to pass brush for the delete object app and that's it that should be it for the driver now we want to head over to the user mode program and we need to create a function to draw the box so it's going to be the same as these other functions that we have here going to be called draw box and it's going to take uh quite a few parameters going to take the x y width height thickness r e and b we don't need these two don't need these two either also i forgot to mention um since we changed the struct we need to copy it and paste it into the user mode one you want to make sure that the struct is the exact same in the user mode program and the driver you also want to make sure in the user mode program that you change the function name as well otherwise it's not going to work you're going to make sure this function name matches the one in the driver and up here okay great so the struct matches the function matches now we need to change these other function calls here anytime you add a new boolean you need to make sure that you're setting that boolean to false in all the other function calls so we've created the draw box boolean and you want to make sure you're setting it to false so i'm going to copy this and you want to paste it in all of the functions i've already done it because like i said before i or just recorded this but the mp4 got corrupted so i have to record it again but you just want to make sure you're pasting it in all the other functions and of course in the draw box function you want to set it to true and set all the other ones to false we'll have to set some more instructions here so we have the x y with height etc the x y width height r e b so we're setting the x y i forgot the thickness good thing i'm double checking out and you want to make sure you do the thickness now down in main i'm just doing a while loop and i'm calling dropbox 5050 size of 50 50 thickness of two and it's red i'm going to build this and let's hope it works now to map the driver i'm using kd mapper google kd mapper
